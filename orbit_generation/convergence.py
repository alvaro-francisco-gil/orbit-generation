"""Scripts to perform the refinement on the generated orbits"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/12_convergence.ipynb.

# %% auto 0
__all__ = ['jl', 'logger', 'differential_correction', 'create_converged_orbits_df', 'process_diferential_correction_orbits']

# %% ../nbs/12_convergence.ipynb 2
from julia.api import Julia
jl = Julia(compiled_modules=False)
from julia import Main
import logging
import numpy as np
import pandas as pd

# %% ../nbs/12_convergence.ipynb 3
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# %% ../nbs/12_convergence.ipynb 5
Main.include("../../julia/convergence_algorithm.jl")

def differential_correction(
    orbit: np.ndarray,
    μ: float,
    variable_time: bool = True,
    time_flight: float = None,
    jacobi_constant: float = None,
    X_end: np.ndarray = None,
    tol: float = 1e-9,
    max_iter: int = 20,
    printout: bool = False,
    DX_0: np.ndarray = None,
    X_big_0: np.ndarray = None,
    δ: float = None
):
    """
    Wrapper for the Julia differential_correction function.
    
    Parameters:
        orbit (np.ndarray): Orbit data with shape [num_timesteps, 7].
        μ (float): Gravitational parameter.
        variable_time (bool): Whether to use variable time nodes.
        time_flight (float, optional): Total time of flight.
        jacobi_constant (float, optional): Jacobi constant.
        X_end (np.ndarray, optional): Terminal state vector (shape: [6]).
        tol (float): Tolerance for convergence.
        max_iter (int): Maximum number of iterations.
        printout (bool): Whether to print iteration logs.
        DX_0 (np.ndarray, optional): Initial guess for state vector correction.
        X_big_0 (np.ndarray, optional): Auxiliary initial guess.
        δ (float, optional): Step size or perturbation parameter.

    Returns:
        tuple: (X_corrected, t_corrected, norm_F_or_G, iterations, success)
    """

    # Convert Python None to Julia 'nothing' using an empty list
    julia_time_flight = [] if time_flight is None else float(time_flight)
    julia_jacobi_constant = [] if jacobi_constant is None else float(jacobi_constant)
    julia_X_end = [] if X_end is None else Main.Vector(X_end.tolist())
    julia_DX_0 = [] if DX_0 is None else Main.Vector(DX_0.tolist())
    julia_X_big_0 = [] if X_big_0 is None else Main.Vector(X_big_0.tolist())
    julia_δ = [] if δ is None else float(δ)

    # Convert NumPy array to Julia array
    julia_orbit = Main.Matrix(orbit.tolist())

    # Call the Julia function
    result = Main.differential_correction(
        julia_orbit,
        μ,
        variable_time=variable_time,
        time_flight=julia_time_flight,
        jacobi_constant=julia_jacobi_constant,
        X_end=julia_X_end,
        tol=tol,
        max_iter=max_iter,
        printout=printout,
        DX_0=julia_DX_0,
        X_big_0=julia_X_big_0,
        δ=julia_δ
    )

    # Extract results from Julia tuples
    # Assuming the result is a tuple: (X_corrected, t_corrected, norm, iterations, success)
    X_corrected = np.array(result[0]).reshape(-1, 6)
    t_vec_corrected = np.array(result[1]).flatten()
    norm_F_or_G = float(result[2])
    iterations = int(result[3])
    success = int(result[4])

    return X_corrected, t_vec_corrected, norm_F_or_G, iterations, success

# %% ../nbs/12_convergence.ipynb 6
def create_converged_orbits_df(
    converged_indices, 
    orbit_array, 
    converged_orbits, 
    errors, 
    iterations
):
    """
    Creates a DataFrame containing detailed information about converged orbits.
    
    Parameters:
        converged_indices (list): List of orbit indices that have converged.
        orbit_array (np.ndarray): Original array containing all orbit data.
        converged_orbits (np.ndarray): Array containing corrected converged orbits.
        errors (np.ndarray): Array of norm values for each converged orbit.
        iterations (np.ndarray): Array of iteration counts for each converged orbit.
    
    Returns:
        pd.DataFrame: DataFrame with detailed information about each converged orbit.
    """
    data = []
    for idx, orbit_index in enumerate(converged_indices):
        initial_orbit = orbit_array[orbit_index]
        corrected_orbit = converged_orbits[idx]
        
        # Extract old and new periods
        old_period = initial_orbit[-1, 0]
        new_period = corrected_orbit[-1, 0]
        
        # Extract initial state from the original orbit
        initial_state = initial_orbit[0, 1:7]  # [pos_x0, pos_y0, pos_z0, vel_x0, vel_y0, vel_z0]
        
        # Extract initial state from the corrected orbit
        final_state = corrected_orbit[0, 1:7]
        
        # Compile the data row
        row = {
            'id': orbit_index,
            'old_period': old_period,
            'new_period': new_period,
            'iterations_convergence': iterations[idx],
            'error': errors[idx],
            'initial_pos_x0': initial_state[0],
            'initial_pos_y0': initial_state[1],
            'initial_pos_z0': initial_state[2],
            'initial_vel_x0': initial_state[3],
            'initial_vel_y0': initial_state[4],
            'initial_vel_z0': initial_state[5],
            'final_pos_x0': final_state[0],
            'final_pos_y0': final_state[1],
            'final_pos_z0': final_state[2],
            'final_vel_x0': final_state[3],
            'final_vel_y0': final_state[4],
            'final_vel_z0': final_state[5]
        }
        data.append(row)
    
    df = pd.DataFrame(data)
    return df

# %% ../nbs/12_convergence.ipynb 7
def process_diferential_correction_orbits(
    orbit_array: np.ndarray, 
    μ: float, 
    variable_time: bool = True, 
    tol: float = 1e-9, 
    max_iter: int = 20, 
    printout: bool = False
):
    """
    Processes a set of orbits by providing the orbit array directly to differential correction.
    
    Parameters:
        orbit_array (np.ndarray): Array containing orbit data with shape [num_orbits, num_timesteps, 7].
                                   The first element in the last dimension is assumed to be time.
        μ (float): Gravitational parameter.
        variable_time (bool, optional): Whether to use variable time nodes for correction. Default is True.
        tol (float, optional): Tolerance for convergence in differential correction. Default is 1e-9.
        max_iter (int, optional): Maximum number of iterations for differential correction. Default is 20.
        printout (bool, optional): Whether to print iteration logs. Default is False.
    
    Returns:
        tuple: (converged_orbits_array, converged_orbits_df)
               - converged_orbits_array: NumPy array with shape [num_converged_orbits, num_timesteps, 7] containing corrected orbits.
               - converged_orbits_df: pandas DataFrame with detailed information about each converged orbit.
    """
    # Lists to store results
    converged_orbits_list = []
    converged_indices = []
    errors_list = []
    iterations_list = []
    
    num_orbits, num_timesteps, data_length = orbit_array.shape
    
    # Validate data_length
    if data_length != 7:
        logger.error("Data length is incorrect. Expected 7 elements (1 time + 6 state components).")
        raise ValueError("Data length is incorrect. Expected 7 elements (1 time + 6 state components).")
    
    # Loop over each orbit
    for i in range(num_orbits):
        logger.info(f"Processing orbit {i+1}/{num_orbits}")
        
        # Extract each orbit
        orbit = orbit_array[i]  # Shape: [num_timesteps, 7]

        # Apply differential correction
        try:
            X_corrected, t_corrected, norm_val, iterations, success_flag = differential_correction(
                orbit=orbit, 
                μ=μ, 
                variable_time=variable_time, 
                tol=tol, 
                max_iter=float(max_iter), 
                printout=printout
            )
        except Exception as e:
            logger.error(f"Orbit {i}: Differential correction failed with error: {e}")
            continue

        logger.info(f"Orbit {i}: Success={success_flag}, Norm={norm_val}, Iterations={iterations}")
                
        # Check the success flag
        if success_flag == 1:
            # If successful, store the corrected orbit and additional info
            corrected_orbit = np.hstack((t_corrected[:, np.newaxis], X_corrected))
            converged_orbits_list.append(corrected_orbit)
            errors_list.append(norm_val)
            iterations_list.append(iterations)
            converged_indices.append(i)
        else:
            # Orbit failed to converge; no action needed since we're not tracking failures
            continue

    # Convert lists to NumPy arrays
    if converged_orbits_list:
        converged_orbits_array = np.array(converged_orbits_list)
        errors_array = np.array(errors_list)
        iterations_array = np.array(iterations_list)
    else:
        converged_orbits_array = np.empty((0, num_timesteps, 7))
        errors_array = np.array([])
        iterations_array = np.array([])
    
    # Create DataFrame for converged orbits
    if converged_orbits_list:
        converged_orbits_df = create_converged_orbits_df(
            converged_indices=converged_indices,
            orbit_array=orbit_array,
            converged_orbits=converged_orbits_array,
            errors=errors_array,
            iterations=iterations_array
        )
    else:
        converged_orbits_df = pd.DataFrame(columns=[
            'id', 'old_period', 'new_period', 'iterations_convergence', 'error',
            'initial_pos_x0', 'initial_pos_y0', 'initial_pos_z0',
            'initial_vel_x0', 'initial_vel_y0', 'initial_vel_z0',
            'final_pos_x0', 'final_pos_y0', 'final_pos_z0',
            'final_vel_x0', 'final_vel_y0', 'final_vel_z0'
        ])
    
    return converged_orbits_array, converged_orbits_df
