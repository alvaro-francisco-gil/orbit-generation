"""Scripts to perform the refinement on the generated orbits"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/12_convergence.ipynb.

# %% auto 0
__all__ = ['jl', 'differential_correction']

# %% ../nbs/12_convergence.ipynb 2
from julia.api import Julia
jl = Julia(compiled_modules=False)
from julia import Main

# %% ../nbs/12_convergence.ipynb 5
Main.eval("""
using DifferentialEquations
using Polynomials
using LinearAlgebra

dim = 6  # state dimension

using ThreeBodyProblem

function constraints(X, t_vec, μ; X_end = [], time_flight = [], jacobi_constant = [], variable_time = true)
    n = length(t_vec)
    T_vec = t_vec[2:end] - t_vec[1:end-1]

    if isempty(time_flight) && isempty(jacobi_constant)
        dim_F = n*6
    elseif !isempty(time_flight)
        dim_F = n*6 + 1
    elseif !isempty(jacobi_constant)
        dim_F = n*6 + 1
    end

    if variable_time
        X_big = vcat(X..., T_vec)
    else
        X_big = vcat(X...)
    end

    F = zeros(dim_F)
    DF = zeros(dim_F, length(X_big))

    for i in 1:(n-1)
        ind_x = (i-1)*6 .+ (1:6)
        ind_y = (i-1)*6 .+ (1:12)
        Xf_i, Phi = get_state(X[i], T_vec[i], μ)
        F[ind_x] = Xf_i - X[i+1]
        DF[ind_x, ind_y] = hcat(Phi, -Diagonal(ones(6)))
        if variable_time
            DF[ind_x, 6*n + i] = dynamics_crtbp(Xf_i, μ)
        end
    end

    if isempty(X_end)
        F[n*6 .+ (-5:0)] = X[end] - X[1]
        DF[n*6 .+ (-5:0), n*6 .+ (-5:0)] = Diagonal(ones(6))
        DF[n*6 .+ (-5:0), 1:6] = -Diagonal(ones(6))
    else
        F[n*6 .+ (-5:0)] = X[end] - X_end
        DF[n*6 .+ (-5:0), n*6 .+ (-5:0)] = Diagonal(ones(6))
    end

    if !isempty(time_flight)
        F[end] = sum(T_vec) - time_flight
        DF[end, end .+ (-(n-2):0)] = transpose(ones(n-1))
    elseif !isempty(jacobi_constant)
        J = 0
        kk = n
        for i in 1:kk
            _, J_i, DJ_i = jacobi(X[i], μ)
            J += J_i
            DF[end, (i-1)*6 .+ (1:6)] = DJ_i
        end
        F[end] = J - kk*jacobi_constant
    end

    return X_big, F, DF
end

function differential_correction(X_old, t_vec_old, μ; variable_time = true, time_flight = [], jacobi_constant = [], X_end = [], tol = 1e-9, max_iter = 20, printout = false, DX_0 = [], X_big_0 = [], δ = [])
    k = 0
    n = length(t_vec_old)

    if !variable_time && !isempty(time_flight)
        error("Set the time nodes as variables to specify the time of flight.")
    end

    while k < max_iter
        k += 1
        global X_big, F, DF = constraints(X_old, t_vec_old, μ; X_end = X_end, time_flight = time_flight, jacobi_constant = jacobi_constant, variable_time = variable_time)

        if isempty(DX_0)
            if norm(F) <= tol && t_vec_old[end] > 1e-6
                printout && print("converged in ", k, " iterations \\n")
                success = 1
                return X_old, t_vec_old, norm(F), k, success
            elseif norm(F) >= 10 && k > 1
                printout && print("solution diverged after ", k, " iterations \\n")
                success = -1
                return X_old, t_vec_old, norm(F), k, success
            end

            X_big_new = X_big - pinv(DF) * F
        else
            arc_constr = dot(X_big - X_big_0, DX_0) - δ
            global G = vcat(F, arc_constr)
            DG = vcat(DF, reduce(hcat, DX_0))

            if norm(G) <= tol && t_vec_old[end] > 1e-6
                printout && print("converged in ", k, " iterations \\n")
                success = 1
                return X_old, t_vec_old, norm(G), k, success
            elseif norm(G) >= 10 && k > 1
                printout && print("solution diverged after ", k, " iterations \\n")
                success = -1
                return X_old, t_vec_old, norm(G), k, success
            end

            X_big_new = X_big - pinv(DG) * G
        end

        X_new = []
        for i = 1:n
            push!(X_new, X_big_new[(i-1)*6 .+ (1:6)])
        end

        if variable_time
            t_vec_new = zeros(1)
            for i = 1:n-1
                push!(t_vec_new, t_vec_new[end] + X_big_new[6*n + i])
            end
            t_vec_old = copy(t_vec_new)
        end

        X_old = copy(X_new)

        if isempty(DX_0)
            printout && print(k, " | ", norm(F), "\\n")
        else
            printout && print(k, " | ", norm(G), "\\n")
        end
    end

    success = -1
    if isempty(DX_0)
        return X_old, t_vec_old, norm(F), k, success
    else
        return X_old, t_vec_old, norm(G), k, success
    end
end
""")

# Python wrapper for differential_correction function
def differential_correction(X_old, t_vec_old, μ, variable_time=True, time_flight=None, 
                            jacobi_constant=None, X_end=None, tol=1e-9, max_iter=20, 
                            printout=False, DX_0=None, X_big_0=None, δ=None):
    # Convert Python None to Julia nothing
    time_flight = [] if time_flight is None else time_flight
    jacobi_constant = [] if jacobi_constant is None else jacobi_constant
    X_end = [] if X_end is None else X_end
    DX_0 = [] if DX_0 is None else DX_0
    X_big_0 = [] if X_big_0 is None else X_big_0
    δ = [] if δ is None else δ

    # Convert NumPy arrays to Julia arrays
    X_old_julia = Main.eval(f'Array{{Float64, 2}}(reshape({X_old.tolist()}, size({X_old.tolist()})))')
    t_vec_old_julia = Main.eval(f'Array{{Float64, 2}}({t_vec_old.tolist()},size({X_old.tolist()}))')

    return Main.differential_correction(X_old_julia, t_vec_old_julia, μ, variable_time=variable_time, 
                                        time_flight=time_flight, jacobi_constant=jacobi_constant, 
                                        X_end=X_end, tol=tol, max_iter=max_iter, printout=printout, 
                                        DX_0=DX_0, X_big_0=X_big_0, δ=δ)
