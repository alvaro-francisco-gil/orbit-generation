"""Necessary scripts to visualize orbits"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_visualization.ipynb.

# %% auto 0
__all__ = ['plot_3d_points', 'visualize_static_orbits', 'visualize_orbits_minimal', 'export_dynamic_orbits_html',
           'plot_grouped_features', 'plot_value_proportions']

# %% ../nbs/03_visualization.ipynb 2
import numpy as np
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from typing import Optional, List, Dict, Union

# %% ../nbs/03_visualization.ipynb 5
def plot_3d_points(data, plot_velocity=True, arrow_width=0.005):
    """
    Plots each point in space with a 3D arrow based on the first 3 coordinates (position)
    and the next 3 coordinates (velocity).

    Parameters:
    data (numpy.ndarray): Array of shape (samples, 6, 1) where:
                          - data[:, 0:3, 0] represents the 3D positions (x, y, z)
                          - data[:, 3:6, 0] represents the velocity components (vx, vy, vz)
    plot_velocity (bool): If True, plot arrows representing velocity vectors.
    arrow_width (float): Width of the arrows.
    """
    # Reshape data to remove the last singleton dimension for easier access
    data = data.reshape(-1, 6)

    # Extract position (x, y, z) and velocity (vx, vy, vz) components
    positions = data[:, 0:3]
    velocities = data[:, 3:6]

    # Create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    # Plot each point with an arrow
    for pos, vel in zip(positions, velocities):
        # Plot the point in space
        ax.scatter(pos[0], pos[1], pos[2], color='blue')

        # Add an arrow representing the velocity vector if plot_velocity is True
        if plot_velocity:
            ax.quiver(
                pos[0], pos[1], pos[2],  # Starting point of the arrow
                vel[0], vel[1], vel[2],  # Direction and length of the arrow
                color='red', length=1, normalize=True,
                linewidths=arrow_width
            )

    # Set labels
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")

    # Set limits to fully see the arrows within the plot
    x_limits = [np.min(positions[:, 0]) - 1, np.max(positions[:, 0]) + 1]
    y_limits = [np.min(positions[:, 1]) - 1, np.max(positions[:, 1]) + 1]
    z_limits = [np.min(positions[:, 2]) - 1, np.max(positions[:, 2]) + 1]
    ax.set_xlim(x_limits)
    ax.set_ylim(y_limits)
    ax.set_zlim(z_limits)

    # Show plot
    plt.show()

# %% ../nbs/03_visualization.ipynb 8
def visualize_static_orbits(data: np.ndarray,  # The orbit data with shape (num_orbits, 6, num_time_points).
                            time_instants: Optional[List[int]] = None,  # Time points to highlight; defaults to None.
                            orbit_indices: Optional[List[int]] = None,  # Indices of orbits to visualize; defaults to all.
                            point_dict: Optional[Dict[str, tuple]] = None,  # Dictionary of extra points to plot.
                            show_legend: bool = True,  # Flag to indicate whether to show a legend.
                            save_path: Optional[str] = None,  # Path to save the figure; defaults to None.
                            plot_reference_box: bool = True  # Flag to indicate whether to plot the reference box.
                           ) -> None:
    """
    Visualizes orbits in 3D space and highlights specified time instants for each selected orbit.
    """
    
    # Use Matplotlib's Computer Modern font
    plt.rcParams.update({
        'font.family': 'serif',
        'font.serif': ['DejaVu Serif'],
        'font.size': 10,
        'text.usetex': False
    })

    if time_instants is None:
        time_instants = []  # Initialize to empty list if None.

    # Validate time instants are within the range of available time points.
    max_time_instants = data.shape[2]
    for time_instant in time_instants:
        if time_instant < 0 or time_instant >= max_time_instants:
            raise ValueError(f"Time instant {time_instant} is out of range.")

    # Validate orbit indices are within the range of available orbits.
    num_orbits = data.shape[0]
    if orbit_indices is None:
        orbit_indices = range(num_orbits)  # Use all orbits by default.
    else:
        for index in orbit_indices:
            if index < 0 or index >= num_orbits:
                raise ValueError(f"Orbit index {index} is out of range.")

    # Setup a 3D plot.
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Plot each selected orbit.
    for index in orbit_indices:
        X = data[index, 0, :]  # X coordinates
        Y = data[index, 1, :]  # Y coordinates
        Z = data[index, 2, :]  # Z coordinates
        ax.plot(X, Y, Z, label=f'Orbit {index}', alpha=0.5)  # Plot each orbit with a label.

    # Generate a color map for time instants if they exist.
    colors = plt.cm.jet(np.linspace(0, 1, len(time_instants)))

    # Highlight specified time instants and add to the legend.
    legend_added = set()  # Track which labels have been added to the legend
    if time_instants:
        for time_instant, color in zip(time_instants, colors):
            for index in orbit_indices:
                posx, posy, posz = data[index, 0:3, time_instant]
                label = f'Time {time_instant}'
                if label not in legend_added:
                    ax.scatter(posx, posy, posz, color=color, s=100, zorder=5, label=label)
                    legend_added.add(label)
                else:
                    ax.scatter(posx, posy, posz, color=color, s=100, zorder=5)

    # Plot additional points if provided.
    if point_dict:
        for point_name, coords in point_dict.items():
            ax.scatter(*coords, label=point_name, s=100, depthshade=True)  # Always add label for point_dict entries.

    # Set labels and title.
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    plt.title('3D Orbits Static Visualization')

    # Display the legend if requested.
    if show_legend:
        ax.legend()

    # Set the background color and plot reference box if requested.
    if plot_reference_box:
        ax.set_facecolor('white')  # White background
        ax.grid(True)  # Show grid
        # Set limits for the reference box
        ax.set_xlim([data[:, 0, :].min(), data[:, 0, :].max()])
        ax.set_ylim([data[:, 1, :].min(), data[:, 1, :].max()])
        ax.set_zlim([data[:, 2, :].min(), data[:, 2, :].max()])
    else:
        ax.set_facecolor('white')
        ax.grid(False)
        ax.set_xticks([])
        ax.set_yticks([])
        ax.set_zticks([])

    # Save the figure if a save path is provided.
    if save_path:
        plt.savefig(save_path)

    # Show the plot.
    plt.show()

# %% ../nbs/03_visualization.ipynb 9
def visualize_orbits_minimal(data: np.ndarray,  # The orbit data with shape (num_orbits, 6, num_time_points).
                             orbit_indices: Optional[List[int]] = None,  # Indices of orbits to visualize; defaults to all.
                             time_instants: Optional[List[int]] = None,  # Time points to highlight; defaults to None.
                             save_path: Optional[str] = None  # Path to save the figure; defaults to None.
                            ) -> None:
    """
    Visualizes orbits in 3D space with a completely blank background (no axes, no labels, no grid).
    """

    # Validate time instants are within the range of available time points.
    max_time_instants = data.shape[2]
    if time_instants is None:
        time_instants = []
    
    for time_instant in time_instants:
        if time_instant < 0 or time_instant >= max_time_instants:
            raise ValueError(f"Time instant {time_instant} is out of range.")
    
    # Validate orbit indices are within the range of available orbits.
    num_orbits = data.shape[0]
    if orbit_indices is None:
        orbit_indices = range(num_orbits)  # Use all orbits by default.
    else:
        for index in orbit_indices:
            if index < 0 or index >= num_orbits:
                raise ValueError(f"Orbit index {index} is out of range.")

    # Setup a 3D plot with a transparent figure and no grid/axes.
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Turn off everything that makes the plot non-blank.
    ax.set_axis_off()  # Removes the axis lines, ticks, labels, etc.
    ax.grid(False)  # Ensure there's no grid.

    # Plot each selected orbit.
    for index in orbit_indices:
        X = data[index, 0, :]  # X coordinates
        Y = data[index, 1, :]  # Y coordinates
        Z = data[index, 2, :]  # Z coordinates
        ax.plot(X, Y, Z, alpha=1.0)  # Full alpha for solid lines.

    # Highlight specified time instants if any are provided.
    if time_instants:
        colors = plt.cm.jet(np.linspace(0, 1, len(time_instants)))  # Generate a color map for the instants.
        for time_instant, color in zip(time_instants, colors):
            for index in orbit_indices:
                posx, posy, posz = data[index, 0:3, time_instant]
                ax.scatter(posx, posy, posz, color=color, s=100, zorder=5)  # Highlight time instant.

    # Save the figure if a save path is provided.
    if save_path:
        plt.savefig(save_path, transparent=True, bbox_inches='tight', pad_inches=0)  # Transparent background.
    
    # Show the plot.
    plt.show()

# %% ../nbs/03_visualization.ipynb 16
def export_dynamic_orbits_html(data: np.ndarray,  # Orbit data as a 3D numpy array (num_orbits, 6, num_time_points).
                               time_instants: Optional[List[int]] = None,  # Time instants to highlight.
                               orbit_indices: Optional[List[int]] = None,  # Indices of orbits to visualize.
                               point_dict: Optional[Dict[str, tuple]] = None,  # Named points as a dict with 3D coordinates.
                               filename: str = 'orbits.html'  # Path and name of the file to save the HTML plot.
                               ) -> None:
    """
    Generates an interactive 3D visualization of orbits and saves it as an HTML file, including the ability to
    highlight specific time instants and show named points.
    """
    if time_instants is None:
        time_instants = []  # Ensure time_instants is initialized if None.

    num_orbits = data.shape[0]  # Total number of orbits in the dataset.
    if orbit_indices is None:
        orbit_indices = list(range(num_orbits))  # Default to visualizing all orbits if none specified.

    fig = go.Figure()  # Initialize the plotly figure.

    # Validate and plot each orbit.
    for index in orbit_indices:
        if index < 0 or index >= num_orbits:
            raise ValueError(f"Orbit index {index} is out of range.")
        
        # Extract coordinates for the plot.
        X = data[index, 0, :]  # X coordinates.
        Y = data[index, 1, :]  # Y coordinates.
        Z = data[index, 2, :]  # Z coordinates.
        fig.add_trace(go.Scatter3d(x=X, y=Y, z=Z, mode='lines',
                                   name=f'Orbit {index}',
                                   legendgroup=f'orbit{index}',
                                   showlegend=True))

        # Highlight specific time instants.
        if time_instants:
            for timestamp in time_instants:
                if timestamp < 0 or timestamp >= data.shape[2]:
                    raise ValueError(f"The provided timestamp {timestamp} is out of range.")
                highlight_x = [data[index, 0, timestamp]]
                highlight_y = [data[index, 1, timestamp]]
                highlight_z = [data[index, 2, timestamp]]
                fig.add_trace(go.Scatter3d(x=highlight_x, y=highlight_y, z=highlight_z, mode='markers',
                                           marker=dict(size=5, color='red'),
                                           name=f'Highlight {index} @ {timestamp}',
                                           legendgroup=f'orbit{index}',
                                           showlegend=False))

    # Add additional points from point_dict to the plot.
    if point_dict:
        for point_name, coords in point_dict.items():
            fig.add_trace(go.Scatter3d(x=[coords[0]], y=[coords[1]], z=[coords[2]], mode='markers',
                                       marker=dict(size=5),
                                       name=point_name))

    # Configure the layout of the plot.
    fig.update_layout(title='3D Orbits Visualization',
                      scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'),
                      width=800, height=600,
                      legend_title="Orbits Legend",
                      clickmode='event+select')

    # Write the plot to an HTML file.
    fig.write_html(filename)
    print(f"Visualization saved to {filename}")

# %% ../nbs/03_visualization.ipynb 21
def plot_grouped_features(df: pd.DataFrame,               # DataFrame containing the data.
                          columns: List[str],             # List of column names to plot.
                          group_col: str,                 # Column name to group by.
                          plot_type: str                  # Type of plot: 'violin', 'box', 'facetgrid', or 'histogram'
                         ) -> None:
    """
    Group the DataFrame by a specified column and plot the specified type of plot for each column for each group.
    """
    if plot_type not in ['violin', 'box', 'facetgrid', 'histogram']:
        raise ValueError("plot_type must be one of 'violin', 'box', 'facetgrid', or 'histogram'")
    
    if plot_type in ['violin', 'box']:
        # Set up the matplotlib figure
        fig, axs = plt.subplots(1, len(columns), figsize=(5 * len(columns), 5))
        
        # If only one column, axs is not an array, so make it an array
        if len(columns) == 1:
            axs = [axs]
        
        # Plot each specified column
        for i, column in enumerate(columns):
            if plot_type == 'violin':
                sns.violinplot(x=group_col, y=column, data=df, ax=axs[i])
                axs[i].set_title(f'Violin plot of {column.capitalize()} by {group_col.capitalize()}')
            elif plot_type == 'box':
                sns.boxplot(x=group_col, y=column, data=df, ax=axs[i])
                axs[i].set_title(f'Box plot of {column.capitalize()} by {group_col.capitalize()}')
            axs[i].set_xlabel(group_col.capitalize())
            axs[i].set_ylabel(column.capitalize())
        
        # Adjust layout and show the plot
        plt.tight_layout()
        plt.show()

    elif plot_type == 'facetgrid':
        for column in columns:
            g = sns.FacetGrid(df, col=group_col, col_wrap=4, height=4, sharex=False, sharey=False)
            g.map(plt.hist, column, bins=20, edgecolor='black')
            g.set_axis_labels(column.capitalize(), 'Frequency')
            g.set_titles(col_template=f"{column.capitalize()} | {{col_name}} {group_col}")
            plt.show()

    elif plot_type == 'histogram':
        # Group by the specified column
        grouped = df.groupby(group_col)

        # Plot histograms for each group
        for group_name, group in grouped:
            num_columns = len(columns)
            fig, axs = plt.subplots(1, num_columns, figsize=(5 * num_columns, 5))
            
            # If only one column, axs is not an array, so make it an array
            if num_columns == 1:
                axs = [axs]
            
            # Plot each specified column
            for i, column in enumerate(columns):
                axs[i].hist(group[column], bins=20, edgecolor='black')
                axs[i].set_title(f'{column.capitalize()} for {group_col.capitalize()}: {group_name}')
                axs[i].set_xlabel(column.capitalize())
                axs[i].set_ylabel('Frequency')
                axs[i].grid(True)
            
            # Adjust layout and show the plot
            plt.tight_layout()
            plt.show()

# %% ../nbs/03_visualization.ipynb 22
def plot_value_proportions(data: Optional[Union[List[int], np.ndarray]],  # List or array of ID values to filter the DataFrame.
                           classification_df: pd.DataFrame,               # DataFrame containing the data.
                           id_col_classification: Optional[str] = None,   # Column name to be used as ID.
                           grid: Optional[str] = 'horizontal',            # Option to plot in grid (horizontal, vertical, or square) or separate images.
                           show_percentages: Union[bool, List[bool]] = True, # Option to print or not print percentages.
                           show_labels: Union[bool, List[bool]] = True,      # Option to print or not print labels.
                           percentage_font_size: int = 10,                # Font size for percentages.
                           label_distance: float = 1.1,                   # Distance of labels from center.
                           pct_distance: float = 0.85,                    # Distance of percentages from center.
                           explode_factor: float = 0.1                    # Factor to separate slices.
                          ) -> None:
    """
    Count occurrences of each unique value in data, map those counts to the DataFrame,
    and plot the proportions in pie charts for each column except the ID column.
    """
    if data is not None:
        if isinstance(data, np.ndarray):
            data = data.tolist()
        data_series = pd.Series(data)
        data_counts = data_series.value_counts()
        # Map counts to the DataFrame
        if id_col_classification:
            labels = classification_df.set_index(id_col_classification).loc[data_series].index
        else:
            labels = classification_df.loc[data_series.index].index
    else:
        labels = classification_df.index

    label_counts = pd.Series(labels).value_counts()

    def make_autopct(values):
        def my_autopct(pct):
            total = sum(values)
            val = int(round(pct * total / 100.0))
            return f'{pct:.1f}%' if show_percentages else None
        return my_autopct

    columns_to_plot = [col for col in classification_df.columns if col != id_col_classification]
    num_cols = len(columns_to_plot)
    alphabet = 'abcdefghijklmnopqrstuvwxyz'

    # Handle list or single boolean for show_percentages and show_labels
    if isinstance(show_percentages, bool):
        show_percentages = [show_percentages] * num_cols
    if isinstance(show_labels, bool):
        show_labels = [show_labels] * num_cols

    def plot_pie(ax, values, title, idx, show_pct, show_lbl):
        explode = [explode_factor] * len(values)
        autopct = make_autopct(values) if show_pct else None
        labels = values.index if show_lbl else None
        ax.pie(values, labels=labels, autopct=autopct, startangle=140,
               textprops={'fontsize': percentage_font_size}, labeldistance=label_distance if show_lbl else None,
               pctdistance=pct_distance if show_pct else None, explode=explode)
        ax.set_title(f'{alphabet[idx]}) {title}')
        ax.axis('equal')
        total_classes = len(values)
        ax.text(0, 0, str(total_classes), ha='center', va='center', fontsize=12, weight='bold')

    if grid == 'horizontal':
        fig, axes = plt.subplots(1, num_cols, figsize=(num_cols * 6, 6))
        axes = np.atleast_1d(axes)  # Ensure axes is always an array, even with a single subplot
        for i, column in enumerate(columns_to_plot):
            values = classification_df[column].reindex(labels).value_counts()
            plot_pie(axes[i], values, f'Proportion of orbits by {column}', i, show_percentages[i], show_labels[i])
        plt.tight_layout()
        plt.show()
    elif grid == 'vertical':
        fig, axes = plt.subplots(num_cols, 1, figsize=(6, num_cols * 6))
        axes = np.atleast_1d(axes)  # Ensure axes is always an array, even with a single subplot
        for i, column in enumerate(columns_to_plot):
            values = classification_df[column].reindex(labels).value_counts()
            plot_pie(axes[i], values, f'Proportion of orbits by {column}', i, show_percentages[i], show_labels[i])
        plt.tight_layout()
        plt.show()
    elif grid == 'square':
        grid_size = int(np.ceil(np.sqrt(num_cols)))
        fig, axes = plt.subplots(grid_size, grid_size, figsize=(grid_size * 6, grid_size * 6))
        axes = axes.flatten()  # Flatten the 2D array of axes to make indexing easier
        for i, column in enumerate(columns_to_plot):
            values = classification_df[column].reindex(labels).value_counts()
            plot_pie(axes[i], values, f'Proportion of orbits by {column}', i, show_percentages[i], show_labels[i])
        # Hide any unused subplots
        for j in range(i + 1, len(axes)):
            fig.delaxes(axes[j])
        plt.tight_layout()
        plt.show()
    else:
        for i, column in enumerate(columns_to_plot):
            plt.figure(figsize=(6, 6))
            values = classification_df[column].reindex(labels).value_counts()
            ax = plt.gca()
            plot_pie(ax, values, f'Proportion of orbits by {column}', i, show_percentages[i], show_labels[i])
            plt.show()
